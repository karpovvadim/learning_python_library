       1. Обзор (Overview)

Модуль io предоставляет основные средства Python для работы с различными типами
ввода/вывода. Существует три основных типа ввода-вывода: текстовый ввод-вывод,
двоичный ввод-вывод и необработанный ввод-вывод (text I/O, binary I/O and raw I/O).
Это общие категории, и для каждой из них можно использовать различные резервные
хранилища. Конкретный объект, относящийся к любой из этих категорий, называется
файловым объектом. Другими распространенными терминами являются поток и
файлоподобный объект (stream and file-like object).

Независимо от категории, каждый конкретный объект потока также будет иметь различные
возможности: он может быть доступен только для чтения, только для записи или для
чтения и записи. Он также может разрешать произвольнo произвольный доступ (поиск в
любом месте вперед или назад) или только последовательный доступ (например, в случае
сокета или канала).

Все потоки внимательно относятся к типу данных, которые вы им предоставляете.
Например, передача объекта str методу write() бинарного потока вызовет ошибку
TypeError. Таким образом, объект bytes будет передан методу write() текстового потока.

Изменено в версии 3.3: Операции, которые раньше вызывали IOError, теперь вызывают
OSError, так как IOError теперь является псевдонимом OSError.

            Текстовый ввод/вывод (Text I/O)

Текстовый ввод-вывод ожидает и создает объекты str. Это означает, что всякий раз,
когда резервное хранилище изначально состоит из байтов (например, в случае файла),
кодирование и декодирование данных выполняются прозрачно, а также необязательный
перевод символов новой строки для конкретной платформы.

Самый простой способ создать текстовый поток — использовать open(), опционально
указав кодировку:
    f = open("myfile.txt", "r", encoding="utf-8")

Текстовые потоки в памяти также доступны как объекты StringIO:
    f = io.StringIO("some initial text data")

API текстового потока подробно описано в документации TextIOBase.
            Двоичный ввод-вывод (Binary I/O)

Двоичный ввод-вывод (также называемый буферизованным вводом-выводом) ожидает объекты,
подобные байтам, и создает объекты байтов. Кодирование, декодирование или перевод
новой строки не выполняются. Эта категория потоков может использоваться для всех
видов нетекстовых данных, а также когда требуется ручное управление обработкой
текстовых данных.

Самый простой способ создать двоичный поток — использовать open() с 'b' в строке режима:
    f = open("myfile.jpg", "rb")

Двоичные потоки в памяти также доступны как объекты BytesIO:
    f = io.BytesIO(b"some initial binary data: \x00\x01")
                    (некоторые исходные двоичные данные)

API бинарного потока подробно описан в документации BufferedIOBase.

Другие библиотечные модули могут предоставлять дополнительные способы создания
текстовых или двоичных потоков. См., например, socket.socket.makefile().

            Необработанный ввод-вывод (Raw I/O)

Необработанный ввод-вывод (также называемый небуферизованным вводом-выводом) обычно
используется в качестве низкоуровневого строительного блока для двоичных и текстовых
потоков; редко бывает полезно напрямую манипулировать необработанным потоком из
пользовательского кода. Тем не менее вы можете создать необработанный поток, открыв
файл в двоичном режиме с отключенной буферизацией:
    f = open("myfile.jpg", "rb", buffering=0)

API необработанного потока подробно описан в документации RawIOBase.

           2. Кодировка текста (Text Encoding)

Кодировка TextIOWrapper и open() по умолчанию зависит от локали (locale.getencoding()).

Однако многие разработчики забывают указать кодировку при открытии текстовых файлов,
закодированных в UTF-8 (например, JSON, TOML, Markdown и т. д.), поскольку большинство
платформ Unix по умолчанию используют локаль UTF-8. Это вызывает ошибки, потому что
кодировка локали не является UTF-8 для большинства пользователей Windows. Например:
with open("README.md") as f:
    long_description = f.read()
Может не работать в Windows, если в файле есть символы, отличные от ASCII.

Соответственно, настоятельно рекомендуется явно указывать кодировку при открытии
текстовых файлов. Если вы хотите использовать UTF-8, передайте encoding="utf-8".
Чтобы использовать текущую кодировку локали, encoding="locale" поддерживается,
начиная с Python 3.10.

Предупреждение о включении EncodingWarning (Opt-in EncodingWarning)

Новое в версии 3.10: дополнительные сведения см. в PEP 597.
Чтобы узнать, где используется кодировка локали по умолчанию, вы можете включить
параметр командной строки -X warn_default_encoding или установить переменную среды
PYTHONWARNDEFAULTENCODING, которая будет выдавать EncodingWarning при использовании
кодировки по умолчанию.

Если вы предоставляете API, который использует open() или TextIOWrapper и передает
encoding=None в качестве параметра, вы можете использовать text_encoding(), чтобы
вызывающие API выдавали EncodingWarning, если они не передают кодировку. Однако
рассмотрите возможность использования UTF-8 по умолчанию (т. е. encoding="utf-8")
для новых API.
