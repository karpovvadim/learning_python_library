os — Miscellaneous operating system interfaces
   — Различные интерфейсы операционной системы

Исходный код: Lib/os.py

Этот модуль предоставляет портативный способ использования функций, зависящих от
операционной системы. Если вы просто хотите прочитать или записать файл, см. open(),
если вы хотите манипулировать путями, см. модуль os.path, и если вы хотите прочитать
все строки во всех файлах в командной строке, см. модуль fileinput. Для создания
временных файлов и каталогов см. модуль tempfile, а для высокоуровневой обработки
файлов и каталогов см. модуль Shutil.

Примечания о доступности этих функций:

     Конструкция всех встроенных модулей Python, зависящих от операционной системы,
     такова, что, пока доступны одни и те же функции, они используют один и тот же
     интерфейс; например, функция os.stat(path) возвращает статистическую информацию
     о пути в том же формате (который появился в интерфейсе POSIX).

     Расширения, свойственные той или иной операционной системе, также доступны через
     модуль os, но их использование, конечно, представляет собой угрозу переносимости.

     Все функции, принимающие пути или имена файлов, принимают как байтовые, так и
     строковые объекты и приводят к объекту того же типа, если возвращается путь или
     имя файла.

     В VxWorks не поддерживаются os.popen, os.fork, os.execv и os.spawn*p*.

     На платформах WebAssembly wasm32-emscripten и wasm32-wasi большие части модуля
     os недоступны или ведут себя по-разному. API, связанные с процессами (например,
     fork(), execve()), сигналами (например, kill(), wait()) и ресурсами (например,
     nice()), недоступны. Другие, такие как getuid() и getpid(), являются
     эмулируемыми или заглушками.

    Примечание

Все функции в этом модуле вызывают OSError (или их подклассы) в случае недопустимых
или недоступных имен файлов и путей или других аргументов, которые имеют правильный
тип, но не принимаются операционной системой.

    exception os.error (исключение os.error)
Псевдоним для встроенного исключения OSError.

    os.name
Имя импортируемого модуля, зависящего от операционной системы. На данный момент
зарегистрированы следующие имена: 'posix', 'nt', 'java'.

     Смотрите также
sys.platform имеет более тонкую детализацию. os.uname() предоставляет
системно-зависимую информацию о версии.
Платформенный модуль обеспечивает подробные проверки подлинности системы.

        Имена файлов, аргументы командной строки и переменные среды

В Python имена файлов, аргументы командной строки и переменные среды представлены
с использованием строкового типа. В некоторых системах декодирование этих строк
в байты и обратно необходимо перед передачей их в операционную систему. Python
использует кодировку файловой системы и обработчик ошибок для выполнения этого
преобразования (см. sys.getfilesystemencoding()).

Кодировка файловой системы и обработчик ошибок настраиваются при запуске Python с
помощью функции PyConfig_Read(): см. члены filesystem_encoding и filesystem_errors
PyConfig.

Изменено в версии 3.1: В некоторых системах преобразование с использованием
кодировки файловой системы может завершиться ошибкой. В этом случае Python
использует обработчик ошибок кодирования surrogateescape, что означает, что
недекодируемые байты заменяются символом Unicode U+DCxx при декодировании, и они
снова преобразуются в исходный байт при кодировании.

Кодировка файловой системы должна гарантировать успешное декодирование всех байтов
ниже 128. Если кодировка файловой системы не обеспечивает эту гарантию, функции
API могут вызвать ошибку UnicodeError.
См. также кодировку локали.

                     Режим Python UTF-8

Новое в версии 3.7: дополнительные сведения см. в PEP 540.

Режим Python UTF-8 игнорирует кодировку локали и принудительно использует кодировку UTF-8:
1. Используйте UTF-8 в качестве кодировки файловой системы.
2. sys.getfilesystemencoding() возвращает «utf-8».
3. locale.getpreferredencoding() возвращает 'utf-8' (аргумент do_setlocale не действует).
sys.stdin, sys.stdout и sys.stderr используют UTF-8 в качестве текстовой
кодировки, при этом для sys.stdin и sys.stdout включен обработчик ошибок
surrogateescape (sys.stderr продолжает использовать обратную косую черту, как
и в режим по умолчанию с учетом локали)
4. В Unix os.device_encoding() возвращает 'utf-8', а не кодировку устройства.

Обратите внимание, что стандартные настройки потока в режиме UTF-8 могут быть
переопределены с помощью PYTHONIOENCODING (так же, как они могут быть в режиме с
учетом локали по умолчанию).

Как следствие изменений в этих API более низкого уровня, другие API более высокого
уровня также демонстрируют другое поведение по умолчанию:

1. Аргументы командной строки, переменные среды и имена файлов декодируются в текст
с использованием кодировки UTF-8.
2. os.fsdecode() и os.fsencode() используют кодировку UTF-8.
3. open(), io.open() и codecs.open() по умолчанию используют кодировку UTF-8. Тем не
менее они по-прежнему используют строгий обработчик ошибок по умолчанию, поэтому попытка
открыть двоичный файл в текстовом режиме, скорее всего, приведет к возникновению
исключения, а не к созданию бессмысленных данных.

Режим Python UTF-8 включается, если локаль LC_CTYPE — C или POSIX при запуске Python
(см. функцию PyConfig_Read()).

Его можно включить или отключить с помощью параметра командной строки -X utf8 и
переменной среды PYTHONUTF8.

Если PYTHONUTF8 переменная окружения вообще не установлена, то интерпретатор по
умолчанию использует текущие настройки локали, если текущая локаль не
идентифицирована как устаревшая локаль на основе ASCII (как описано для
PYTHONCOERCECLOCALE), а приведение локали либо отключено, либо завершается ошибкой.
В таких устаревших локалях интерпретатор по умолчанию будет включать режим UTF-8,
если явно не указано не делать этого.

Режим Python UTF-8 можно включить только при запуске Python. Его значение можно
прочитать из sys.flags.utf8_mode.

См. также режим UTF-8 в Windows и кодировку файловой системы и обработчик ошибок.

Смотрите также:
PEP 686
     Python 3.15 сделает режим Python UTF-8 по умолчанию.

Параметры процесса

Эти функции и элементы данных предоставляют информацию и работают с текущим
процессом и пользователем.

os.ctermid()
     Вернуть имя файла, соответствующее управляющему терминалу процесса.
     Доступность: Unix, не Emscripten, не WASI.
