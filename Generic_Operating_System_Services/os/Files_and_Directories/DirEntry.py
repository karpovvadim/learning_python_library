"""class os.DirEntry"""
# Объект, полученный функцией scandir() для предоставления пути к файлу и других файловых
# атрибутов записи каталога.
# scandir() предоставит как можно больше этой информации без дополнительных системных
# вызовов. При выполнении системного вызова stat() или lstat() объект os.DirEntry кэширует
# результат.
# Экземпляры os.DirEntry не предназначены для хранения в долгоживущих структурах данных;
# если вы знаете, что метаданные файла изменились или с момента вызова scandir() прошло
# много времени, вызовите os.stat(entry.path) для получения актуальной информации.
# Поскольку методы os.DirEntry могут выполнять вызовы операционной системы, они также могут
# вызывать OSError. Если вам нужен очень тонкий контроль над ошибками, вы можете поймать
# OSError при вызове одного из методов os.DirEntry и обработать его соответствующим образом.
# Для непосредственного использования в качестве объекта, подобного пути, os.DirEntry
# реализует интерфейс PathLike.
# Атрибуты и методы экземпляра os.DirEntry следующие:
#
# name
#     Базовое имя файла записи относительно аргумента пути scandir().
#     Атрибут name будет bytes, если аргумент пути scandir() имеет тип bytes и str в
#     противном случае. Используйте fsdecode() для декодирования байтовых имен файлов.
#
# path
#     Полный путь записи: эквивалентно os.path.join(scandir_path, entry.name), где
#     scandir_path — это аргумент пути scandir(). Путь является абсолютным только в том
#     случае, если аргумент пути scandir() был абсолютным. Если аргумент пути scandir()
#     был файловым дескриптором, атрибут пути совпадает с атрибутом имени.
#     Атрибут пути будет bytes, если аргумент пути scandir() имеет тип bytes и str в
#     противном случае. Используйте fsdecode() для декодирования байтовых имен файлов.
#
# inode()
#     Возвращает номер инода записи.
#     Результат кэшируется в объекте os.DirEntry. Используйте os.stat(entry.path, follow_symlinks=False).st_ino для получения актуальной информации.
#     При первом некэшированном вызове требуется системный вызов в Windows, но не в Unix.
#
# is_dir(*, follow_symlinks=True)
#     Вернуть True, если эта запись является каталогом или символической ссылкой,
#     указывающей на каталог; вернуть False, если запись является файлом любого другого типа
#     или указывает на него, или если он больше не существует.
#     Если для параметра follow_symlinks установлено значение False, вернуть значение True
#     только в том случае, если эта запись является каталогом (без следующих символических
#     ссылок); вернуть False, если запись представляет собой файл любого другого типа или
#     если он больше не существует.
#     Результат кэшируется в объекте os.DirEntry с отдельным кешем для Follow_symlinks
#     True и False. Вызовите os.stat() вместе с stat.S_ISDIR(), чтобы получить актуальную
#     информацию.
#     При первом некэшированном вызове системный вызов в большинстве случаев не требуется.
#     В частности, для не символических ссылок ни Windows, ни Unix не требуют системного
#     вызова, за исключением некоторых файловых систем Unix, таких как сетевые файловые системы, которые возвращают dirent.d_type == DT_UNKNOWN. Если запись является символической ссылкой, для перехода по символической ссылке потребуется системный вызов, если только для параметра follow_symlinks не установлено значение False.
#     Этот метод может вызывать OSError, например PermissionError, но FileNotFoundError
#     перехватывается и не вызывается.
#
# is_file(*, follow_symlinks=True)
#      Возвратите True, если эта запись является файлом или символической ссылкой,
#      указывающей на файл; вернуть False, если запись является или указывает на каталог
#      или другую запись, не являющуюся файлом, или если она больше не существует.
#      Если для параметра follow_symlinks установлено значение False, вернуть значение
#      True только в том случае, если эта запись является файлом (без перехода по
#      символическим ссылкам); вернуть False, если запись является каталогом или другой
#      записью, не являющейся файлом, или если она больше не существует.
#      Результат кэшируется в объекте os.DirEntry. Кэширование, сделанные системные вызовы
#      и возбужденные исключения соответствуют is_dir().
#
# is_symlink()
#      Возвратите True, если эта запись является символической ссылкой (даже если она не
#      работает); вернуть False, если запись указывает на каталог или любой файл, или если
#      он больше не существует.
#      Результат кэшируется в объекте os.DirEntry. Вызовите os.path.islink(), чтобы
#      получить актуальную информацию.
#      При первом некэшированном вызове системный вызов в большинстве случаев не требуется.
#      В частности, ни Windows, ни Unix не требуют системного вызова, за исключением
#      некоторых файловых систем Unix, таких как сетевые файловые системы, которые
#      возвращают dirent.d_type == DT_UNKNOWN.
#      Этот метод может вызывать OSError, например PermissionError, но FileNotFoundError
#      перехватывается и не вызывается.
#
# stat(*, follow_symlinks=True)
#      Возвращает объект stat_result для этой записи. Этот метод следует по символическим
#      ссылкам по умолчанию; чтобы указать символическую ссылку, добавьте аргумент
#      follow_symlinks=False.
#      В Unix этот метод всегда требует системного вызова. В Windows системный вызов
#      требуется только в том случае, если для параметра follow_symlinks установлено
#      значение True и запись является точкой повторной обработки (например, символической ссылкой или соединением каталогов).
#      В Windows атрибуты st_ino, st_dev и st_nlink stat_result всегда устанавливаются
#      равными нулю. Вызовите os.stat(), чтобы получить эти атрибуты.
#      Результат кэшируется в объекте os.DirEntry с отдельным кешем для Follow_symlinks
#      True и False. Вызовите os.stat() для получения актуальной информации.
#
# Обратите внимание, что существует хорошее соответствие между несколькими атрибутами и
# методами os.DirEntry и pathlib.Path. В частности, атрибут name имеет то же значение, что
# и методы is_dir(), is_file(), is_symlink() и stat().
#     Новое в версии 3.5.
#     Изменено в версии 3.6: Добавлена поддержка интерфейса PathLike.
#     Добавлена поддержка байтовых путей в Windows.

import os

path = '.'
t = 'unknown'
for entry in os.scandir(path):
    if entry.is_dir():
        t = 'dir'
    elif entry.is_file():
        t = 'file'
    elif entry.is_symlink():
        t = 'link'

    print(f'{entry.name} {t}')
