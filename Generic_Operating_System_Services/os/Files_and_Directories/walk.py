# Файлы и каталоги (Files and Directories)
"""os.walk(top, topdown=True, onerror=None, followlinks=False)"""
# Генерируйте имена файлов в дереве каталогов, проходя по дереву сверху вниз или
# снизу вверх. Для каждого каталога в дереве с корнем в верхней части каталога
# (включая саму вершину) он дает 3 кортежа (путь к каталогу, имена каталогов, имена
# файлов).(dirpath, dirnames, filenames).
# dirpath — это строка, путь к каталогу. dirnames — это список имен подкаталогов в
# пути каталогов (включая символические ссылки на каталоги и исключая «.» и «..»).
# имена файлов — это список имен файлов, не входящих в каталог, в пути к каталогу.
# Обратите внимание, что имена в списках не содержат компонентов пути. Чтобы получить
# полный путь (начинающийся с top) к файлу или каталогу в пути каталога, выполните
# команду os.path.join(путь каталога, имя). Отсортированы ли списки или нет, зависит
# от файловой системы. Если файл удаляется из каталога dirpath или добавляется в него
# во время создания списков, не указано, будет ли включаться имя этого файла.
# Если необязательный аргумент topdown равен True или не указан, тройка для каталога
# генерируется перед тройками для любого из его подкаталогов (каталоги генерируются
# сверху вниз). Если topdown имеет значение False, тройка для каталога генерируется
# после троек для всех его подкаталогов (каталоги генерируются снизу вверх).
# Независимо от значения topdown список подкаталогов извлекается до создания кортежей для каталога и его подкаталогов.
# Когда topdown имеет значение True, вызывающая сторона может изменить список имен
# каталогов на месте (возможно, используя присваивание del или slice), а walk() будет
# рекурсивно обращаться только к подкаталогам, имена которых остаются в именах
# каталогов; это можно использовать для сокращения поиска, установления определенного
# порядка посещения или даже для информирования функции walk() о каталогах, которые
# вызывающая сторона создает или переименовывает, прежде чем она снова возобновит
# работу функции walk(). Изменение имен каталогов, когда для свойства topdown
# установлено значение False, не влияет на поведение обхода, поскольку в восходящем
# режиме каталоги в именах каталогов генерируются до того, как будет создан сам путь
# пути.
# По умолчанию ошибки вызова scandir() игнорируются. Если указан необязательный
# аргумент onerror, он должен быть функцией; он будет вызываться с одним аргументом,
# экземпляром OSError. Он может сообщить об ошибке, чтобы продолжить обход, или
# вызвать исключение, чтобы прервать обход. Обратите внимание, что имя файла доступно
# как атрибут имени файла объекта исключения.
# По умолчанию walk() не будет переходить к символическим ссылкам, которые разрешаются
# в каталоги. Установите для следующих ссылок значение True, чтобы посещать каталоги,
# на которые указывают символические ссылки, в системах, которые их поддерживают.
# Примечание
# Имейте в виду, что установка для последующих ссылок значения True может привести к
# бесконечной рекурсии, если ссылка указывает на родительский каталог самой себя.
# walk() не отслеживает уже посещенные каталоги.
# Примечание
# Если вы передаете относительный путь, не меняйте текущий рабочий каталог между
# повторениями walk(). walk() никогда не изменяет текущий каталог и предполагает, что
# вызывающая его функция тоже этого не делает.
# В этом примере показано количество байтов, занимаемых файлами, не входящими в
# каталоги, в каждом каталоге в начальном каталоге, за исключением того, что он не
# просматривается ни в одном из подкаталогов CVS:
import os
from os.path import join, getsize

print((os.listdir('.')))
path = os.walk('.', topdown=True)
for root, dirs, files in path:
    print(root, "consumes", end=" ")  # потребляет
    print(sum(getsize(join(root, name)) for name in files), end=" ")
    print("bytes in", len(files), "non-directory files")  # файлах, не являющихся каталогами
    if 'CVS' in dirs:
        dirs.remove('CVS')  # не просматриваем каталог `CVS`

# В следующем примере (простая реализация Shutil.rmtree()) необходимо пройти по дереву
# снизу вверх, rmdir() не позволяет удалить каталог до того, как каталог станет пустым:
# заменено на os.path.join:
print('-----------------------------------------------------------')
path = "./Linux_extended_attributes/a/b/c"
try:
    os.makedirs(path, 0o774)
except FileExistsError:
    print(os.path.isdir(path))
for root, dirs, files in os.walk(".", topdown=False):
    for name in files:
        print('     name in files:', os.path.join(root, name))
    for name in dirs:
        print('name in dirs:', os.path.join(root, name))

# Вызывает событие аудита os.walk с аргументами top, topdown, onerror, followlinks.
# Изменено в версии 3.5: эта функция теперь вызывает os.scandir() вместо os.listdir(),
# что делает ее быстрее за счет уменьшения количества вызовов os.stat().
# Изменено в версии 3.6: принимает объект, подобный пути.
