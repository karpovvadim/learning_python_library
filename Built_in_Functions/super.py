""" class super(type, object_or_type=None)"""
# Возвращает прокси-объект, который делегирует вызовы методов родительскому или
# одноуровневому классу типа. Это полезно для доступа к унаследованным методам,
# которые были переопределены в классе.
# object_or_type определяет порядок разрешения метода для поиска. Поиск начинается
# с класса сразу после типа.
# Например, если __mro__ из object_or_type равно D -> B -> C -> A -> объект, а
# значение типа равно B, то super() ищет C -> A -> объект.
# Атрибут __mro__ объекта object_or_type перечисляет порядок поиска разрешения метода,
# используемый как getattr(), так и super(). Атрибут является динамическим и может
# изменяться при каждом обновлении иерархии наследования.
# Если второй аргумент опущен, возвращаемый суперобъект не связан. Если второй
# аргумент является объектом, isinstance(obj, type) должен иметь значение true.
# Если второй аргумент является типом, issubclass(type2, type) должен иметь
# значение true (это полезно для методов класса).
# Есть два типичных случая использования super. В иерархии классов с одиночным
# наследованием super можно использовать для ссылки на родительские классы без
# явного их именования, что делает код более удобным для сопровождения. Это
# использование очень похоже на использование super в других языках программирования.
# Второй вариант использования — поддержка совместного множественного наследования
# в динамической среде выполнения. Этот вариант использования уникален для Python
# и не встречается в статически скомпилированных языках или языках, поддерживающих
# только одиночное наследование. Это позволяет реализовать «ромбовидные диаграммы»,
# в которых несколько базовых классов реализуют один и тот же метод. Хороший дизайн
# требует, чтобы такие реализации имели одну и ту же сигнатуру вызова в каждом случае
# (поскольку порядок вызовов определяется во время выполнения, потому что этот
# порядок адаптируется к изменениям в иерархии классов, и поскольку этот порядок
# может включать одноуровневые классы, неизвестные до времени выполнения).
# В дополнение к поиску методов super() также работает для поиска атрибутов.
# Одним из возможных вариантов использования этого является вызов дескрипторов в
# родительском или одноуровневом классе.
# Обратите внимание, что super() реализован как часть процесса привязки для явного
# поиска атрибутов с точками, таких как super().__getitem__(name). Это достигается
# за счет реализации собственного метода __getattribute__() для поиска классов в
# предсказуемом порядке, который поддерживает совместное множественное наследование.
# Соответственно, super() не определено для неявного поиска с использованием
# инструкций или операторов, таких как super()[name].
# Также обратите внимание, что, помимо формы с нулевым аргументом, super() не
# ограничивается использованием внутренних методов. Форма с двумя аргументами точно
# определяет аргументы и делает соответствующие ссылки. Форма с нулевым аргументом
# работает только внутри определения класса, поскольку компилятор заполняет
# необходимые детали для правильного извлечения определяемого класса, а также
# для доступа к текущему экземпляру для обычных методов.
print("---------С одинарным наследованием--------------------------------")
class Mammal(object):
    def __init__(self, mammalName):
        print(mammalName, 'is a warm-blooded animal.')

class Dog(Mammal):
    def __init__(self):
        print('Dog has four legs.')
        super().__init__('Dog')

d1 = Dog()
print("-------С множественным наследованием------------------------------")

class Animal:
    def __init__(self, Animal):
        print(Animal, 'is an animal.');


class Mammal(Animal):
    def __init__(self, mammalName):
        print(mammalName, 'is a warm-blooded animal.')
        super().__init__(mammalName)


class NonWingedMammal(Mammal):
    def __init__(self, NonWingedMammal):
        print(NonWingedMammal, "can't fly.")
        super().__init__(NonWingedMammal)


class NonMarineMammal(Mammal):
    def __init__(self, NonMarineMammal):
        print(NonMarineMammal, "can't swim.")
        super().__init__(NonMarineMammal)


class Dog(NonMarineMammal, NonWingedMammal):
    def __init__(self):
        print('Dog has 4 legs.')
        super().__init__('Dog')


d = Dog()
print('')
bat = NonMarineMammal('Bat')
# Порядок разрешения методов (MRO) – это порядок, в котором методы должны
# наследоваться при наличии множественного наследования. Вы можете просмотреть MRO,
# используя атрибут __mro__.
print(Dog.__mro__)
# (<class 'Dog'>,
# <class 'NonMarineMammal'>,
# <class 'NonWingedMammal'>,
# <class 'Mammal'>,
# <class 'Animal'>,
# <class 'object'>)
