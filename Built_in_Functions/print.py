"""print(*objects, sep=' ', end='\n', file=None, flush=False)"""
# Печатать объекты в файл текстового потока, разделяя их sep и заканчивая end. sep, end,
# file и flush, если они присутствуют, должны быть заданы как аргументы ключевого слова.
# Все аргументы, не являющиеся ключевыми словами, преобразуются в строки, как это делает str(),
# и записываются в поток, разделенные sep и сопровождаемые end. И sep, и end должны быть
# строками; они также могут быть None, что означает использование значений по умолчанию.
# Если объекты не заданы, print() просто напишет end.
# Аргумент файла должен быть объектом с методом записи (строка); если он отсутствует или
# отсутствует, будет использоваться sys.stdout. Поскольку печатные аргументы преобразуются в
# текстовые строки, функцию print() нельзя использовать с файловыми объектами в двоичном режиме.
# Для этого используйте вместо этого file.write(...).
# file ‒ должен быть объект с методом записи (строковый). Если его опустить, будет использоваться
# sys.stdout, который печатает объекты на экране.
# Буферизация вывода обычно определяется файлом, но если аргумент ключевого слова flush равен
# true, поток принудительно сбрасывается.
# Изменено в версии 3.3: Добавлен аргумент ключевого слова flush.
# Параметры
# objects ‒ объект печатается. * означает, что может быть более одного объекта.
# sep ‒ объекты разделяются sep. Значение по умолчанию: ‘ ‘.
# end ‒ печатается конец.
# file ‒ должен быть объект с методом записи (строковый). Если его опустить, будет
# использоваться sys.stdout, который печатает объекты на экране.
# flush ‒ если True, поток принудительно очищается. Значение по умолчанию: False.
# Примечание: sep, end, file и flush являются аргументами ключевых слов.
print("----С разделителями и конечными параметрами----------------------------")
a = 5
print("a =", a, sep='00000', end='\n\n\n', flush=True)
print("a =", a, sep='0', end='')
print("-----С параметром файла------------------------------------------")
sourceFile = open('python.txt', 'w')
print('Pretty cool, huh!', file=sourceFile, flush=False)
sourceFile.close()
