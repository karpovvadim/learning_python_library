""" class memoryview(object)"""
# Функция memoryview() возвращает объект просмотра памяти для данного аргумента.
# Прежде чем мы перейдем к тому, что такое представления памяти, нам нужно сначала
# понять буферный протокол Python.
# Буферный протокол
# Протокол буфера предоставляет способ доступа к внутренним данным объекта. Эти внутренние
# данные представляют собой массив памяти или буфер.
# Протокол буферов позволяет одному объекту предоставлять свои внутренние данные (буферы),
# а другому ‒ получать доступ к этим буферам без промежуточного копирования. Этот протокол
# доступен нам только на уровне C-API и не использует нашу обычную кодовую базу.
# Итак, чтобы представить тот же протокол для обычной кодовой базы, присутствуют
# представления памяти. Представление памяти ‒ это безопасный способ раскрыть протокол буфера.
# Это позволяет вам получить доступ к внутренним буферам объекта, создав объект
# представления памяти.
# Почему важны протокол буфера и представления памяти?
# Нам нужно помнить, что всякий раз, когда мы выполняем какое-либо действие с объектом
# (вызываем функцию объекта, нарезаем массив), Python необходимо создать копию объекта.
# Если у нас есть большие данные для работы (например, двоичные данные изображения), мы
# без необходимости создавали бы копии огромных фрагментов данных, которые почти бесполезны.
# Используя протокол буфера, мы можем предоставить другому объекту доступ для
# использования/изменения больших данных без их копирования. Это заставляет программу
# использовать меньше памяти и увеличивает скорость выполнения.
# Синтаксис
# Чтобы раскрыть протокол буфера, мы используем этот синтаксис: memoryview(obj)
# Параметры
# Функция принимает единственный параметр:
# obj ‒ объект, внутренние данные которого должны быть выставлены. obj должен поддерживать
# протокол буфера (байты, массив байтов).
# Возвращаемое значение
# Метод возвращает объект просмотра памяти.
print("----1: Как работает?---------------------------------------------")
# random bytearray (случайный массив байтов)
random_byte_array = bytearray('ABC', 'utf-8')
mv = memoryview(random_byte_array)
# access memory view's zeroth index (доступ к нулевому индексу представления памяти)
print("memoryview(bytearray('ABC', 'utf-8')): ", mv[0])
# create byte from memory view (создать байт из представления памяти)
print("создать байт из представления памяти - bytes(mv[0:2]): ", bytes(mv[0:2]))
# create list from memory view  (создать список из представления памяти)
print("создать список из представления памяти list(mv[0:3]): ", list(mv[0:3]))
print("---2: Изменение внутренних данных с помощью просмотра памяти--------")
# random bytearray
random_byte_array = bytearray('ABC', 'utf-8')
print('Before updation:', random_byte_array)
mv = memoryview(random_byte_array)
# update 1st index of mv to Z
mv[1] = 90
print('After updation:', random_byte_array)