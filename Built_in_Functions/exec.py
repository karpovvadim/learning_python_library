"""exec(object, globals=None, locals=None, /, *, closure=None)"""
# Эта функция поддерживает динамическое выполнение кода Python. объект должен быть либо
# строкой, либо объектом кода. Если это строка, она анализируется как набор операторов
# Python, которые затем выполняются (если не возникает синтаксическая ошибка).
# [1] Если это объект кода, он просто выполняется. Во всех случаях ожидается, что
# исполняемый код будет допустимым для ввода в файл (см. раздел «Ввод в файл» в Справочном
# руководстве). Имейте в виду, что операторы nonlocal, yield и return нельзя использовать
# вне определений функций, даже в контексте кода, переданного в функцию exec().
# Возвращаемое значение — Нет.
# Во всех случаях, если необязательные части опущены, код выполняется в текущей области.
# Если предоставлены только глобальные переменные, это должен быть словарь (а не
# подкласс словаря), который будет использоваться как для глобальных, так и для
# локальных переменных. Если заданы глобальные и локальные переменные, они используются
# для глобальных и локальных переменных соответственно. Если предоставлено, локальные
# могут быть любыми объектами сопоставления. Помните, что на уровне модуля глобальные
# и локальные переменные — это один и тот же словарь. Если exec получает два отдельных
# объекта в  качестве глобального и локального, код будет выполняться так, как если бы
# он был встроен в определение класса.
# Если словарь глобалов не содержит значения для ключа __builtins__, под этим ключом
# вставляется ссылка на словарь встроенных модулей. Таким образом, вы можете
# контролировать, какие встроенные функции доступны для исполняемого кода, вставляя свой
# собственный словарь __builtins__ в глобальные переменные перед передачей его в exec().
# Аргумент closure определяет замыкание — кортеж переменных ячеек. Это допустимо только
# в том случае, если объект является кодовым объектом, содержащим свободные переменные.
# Длина кортежа должна точно соответствовать количеству свободных переменных, на которые
# ссылается объект кода.
# Вызывает событие аудита exec с объектом кода в качестве аргумента. Также могут
# вызываться события компиляции кода.
# Примечание
# Встроенные функции globals() и locals() возвращают текущий глобальный и локальный
# словари, соответственно, которые может быть полезно передать для использования в
# качестве второго и третьего аргумента exec().
# Примечание
# Локальные переменные по умолчанию действуют так, как описано для функции locals() ниже:
# не следует пытаться модифицировать словарь локальных переменных по умолчанию. Передайте
# явный словарь локальных переменных, если вам нужно увидеть влияние кода на локальные
# переменные после возврата из функции exec().
# Изменено в версии 3.11: Добавлен параметр закрытия.
# Метод exec() выполняет динамически созданную программу, которая представляет
# собой строку или объект кода.
# Синтаксис exec(): exec(object, globals, locals)
# Метод принимает три параметра:
# объект — Либо строка, либо объект кода.
# globals (необязательно) — словарь.
# locals (необязательно) — объект отображения. Словарь — это стандартный и часто
# используемый тип сопоставления в Python.
# exec() не возвращает никакого значения, он возвращает None.
print("-------Разрешить пользователю вводить данные---------------")
program = input('Enter a program:')  # input: [print(item) for item in [1, 2, 3]]
exec(program)
print("[print(item) for item in [1, 2, 3]] >>>")
[print(item) for item in [1, 2, 3]]
# Если вы хотите получить код Python от пользователя, который позволяет использовать
# многострочный код (с использованием ‘\ n’), вы можете использовать метод compile()
# перед использованием exec().
print("--------Многострочный код------\n'a = 5\nb=10\nprint(\"Sum =\", a+b)'----------")
program = 'a = 5\nb=10\nprint("Sum =", a+b)'
exec(program)
# На что обратить внимание? Рассмотрим ситуацию: вы используете систему Unix
# (macOS, Linux и т. Д.) И импортировали модуль ОС. Модуль os предоставляет переносимый
# способ использования функций операционной системы, таких как чтение или запись файла.
# Если вы разрешаете пользователям вводить значение с помощью exec (input()), пользователь
# может вводить команды для изменения файла или даже удалять все файлы с помощью команды
# os.system (‘rm -rf *’).
# Если вы используете в своем коде exec (input()), рекомендуется проверить, какие
# переменные и методы может использовать пользователь. Вы можете увидеть, какие
# переменные и методы доступны, используя метод dir().
import math
exec('print(dir())')
# Передача глобальных параметров
# Параметры globals и locals (словари) используются для глобальных и локальных переменных
# соответственно. Если словарь locals не указан, по умолчанию используется словарь
# globals. Это означает, что глобальные переменные будут использоваться как для
# глобальных, так и для локальных переменных.
print("----Передача пустого словаря в качестве глобального параметра---")
exec('print(dir())', {})
# Если вы передаете пустой словарь в качестве глобальных переменных, объекту доступны
# только __builtins__ (первый параметр для exec()). Несмотря на то, что мы импортировали
# математический модуль в вышеуказанную программу, попытка доступа к любой из функций,
# предоставляемых математическим модулем, вызовет исключение.
# exec('print(sqrt(9))', {})  # This code will raise an exception
print("------Обеспечение доступности определенных методов------")
exec('print(dir())', {'sqrt': math.sqrt, 'pow': pow})
# object can have sqrt() module
print("-----объект может иметь модуль sqrt()--------------------")
# Здесь код, который выполняется exec(), может также иметь методы sqrt() и pow()
# вместе с __builtins__.
exec('print(sqrt(9))', {'sqrt': math.sqrt, 'pow': pow})
print("------Название метода можно изменить по своему желанию.------")
exec('print(dir())', {'squareRoot': math.sqrt, 'pow': pow})
# object can have squareRoot() module
exec('print(squareRoot(9))', {'squareRoot': math.sqrt, 'pow': pow})
print("-----Передача как глобальных, так и локальных словарей--------")
globalsParameter = {'__builtins__': None}
localsParameter = {'print': print, 'dir': dir}
exec('print(dir())', globalsParameter, localsParameter)
# Здесь только два встроенных метода print() и dir() могут быть выполнены методом exec().
# Важно отметить, что exec() выполняет код и не возвращает никакого значения
# (не возвращает None). Следовательно, вы не можете использовать операторы return
# и yield вне определений функций.
