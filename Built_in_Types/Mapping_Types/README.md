            Mapping Types — dict
            Типы сопоставления — dict

Объект dict (Сопоставление) отображает хэшируемые значения на произвольные объекты.
Сопоставления — это изменяемые объекты. В настоящее время существует только один стандартный
тип сопоставления — словари. (Для других контейнеров см. встроенные классы list, set и
tuple, а также модуль collections.)

Ключи словаря — это почти произвольные значения. Значения, отличные от хэшируемых, т. е.
значения, содержащие списки, словари или другие изменяемые типы (которые сравниваются по
значению, а не по идентификатору объекта), не могут использоваться в качестве ключей.
Числовые типы, используемые для ключей, подчиняются обычным правилам числового сравнения:
если два числа сравниваются одинаково (например, 1 и 1.0), то их можно использовать
взаимозаменяемо для индексации одного и того же словарного элемента. (Обратите внимание,
однако, что, поскольку компьютеры хранят числа с плавающей запятой как приближения, обычно
неразумно использовать их в качестве ключей словаря.)

Словари можно создать, поместив разделенный запятыми список пар key: value в фигурные скобки,
например: {'jack': 4098, 'sjoerd': 4127} или {4098: 'jack', 4127: 'sjoerd'}, или с помощью
конструктора dict.

class dict(**kwarg)
class dict(mapping, **kwarg)
class dict(iterable, **kwarg)
    Возвращает новый словарь, инициализированный необязательным позиционным аргументом и,
возможно, пустым набором ключевых аргументов.
    Словари можно создавать несколькими способами:
        Используя разделенный запятыми список пар key: value в фигурных скобках:
{'jack': 4098, 'sjoerd': 4127} или {4098: 'jack', 4127: 'sjoerd'}
        Используя словарное включение: {}, {x: x ** 2 for x in range(10)}
        Используя конструктор типа: dict(), dict([('foo', 100), ('bar', 200)]),
dict(foo=100, bar=200)
    Если позиционный аргумент не указан, создаётся пустой словарь. Если указан позиционный
аргумент, и это объект сопоставления, словарь создаётся с теми же парами ключ-значение, что
и объект сопоставления. В противном случае позиционный аргумент должен быть итерируемым
объектом. Каждый элемент в итерируемом объекте должен быть итерируем ровно с двумя объектами.
Первый объект каждого элемента становится ключом в новом словаре, а второй объект —
соответствующим значением. Если ключ встречается более одного раза, последнее значение для
этого ключа становится соответствующим значением в новом словаре.
    Если указаны ключевые аргументы, ключевые аргументы и их значения добавляются в словарь,
созданный из позиционного аргумента. Если добавляемый ключ уже присутствует, значение из
ключевого аргумента заменяет значение из позиционного аргумента.
    Для иллюстрации все следующие примеры возвращают словарь, равный
{"one": 1, "two": 2, "three": 3}:
    >>> a = dict(one=1, two=2, three=3)
    >>> b = {'one': 1, 'two': 2, 'three': 3}
    >>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
    >>> d = dict([('two', 2), ('one', 1), ('three', 3)])
    >>> e = dict({'three': 3, 'one': 1, 'two': 2})
    >>> a == b == c == d == e
    True

Предоставление ключевых аргументов, как в первом примере, работает только для ключей,
которые являются действительными идентификаторами Python. В противном случае можно
использовать любые действующие ключи.
Это операции, которые поддерживают словари (и, следовательно, пользовательские типы
сопоставления также должны поддерживать):
    list(d)
        Возвращает список всех ключей, используемых в словаре d.
    len(d)
        Возвращает количество элементов в словаре d.
    d[key]
        Возвращает элемент d с помощью ключа key. Вызывает KeyError, если ключ отсутствует
в отображении.
        Если подкласс dict определяет метод __missing__(), а key отсутствует, операция
d[key] вызывает метод с ключом key в качестве аргумента. Затем операция d[key] возвращает
или вызывает все, что было возвращено или вызвано вызовом __missing__(key). Никакие другие
операции или методы не вызывают __missing__(). Если __missing__() не определен, вызывается
KeyError. __missing__() должен быть методом; это не может быть переменной экземпляра:
        >>> class Counter(dict):
        ...     def __missing__(self, key):
        ...         return 0
        >>> c = Counter()
        >>> c['red']
        0
        >>> c['red'] += 1
        >>> c['red']
        1
В приведенном выше примере показана часть реализации collections.Counter. Другой
метод __missing__ используется collections.defaultdict.
    d[key] = value
        Установить d[key] на value.
    del d[key]
        Удалить d[key] из d. Вызывает KeyError, если key отсутствует в отображении.
    key in d
        Возвращает True, если у d есть ключевой key, иначе False.
    key not in d
        Эквивалентен not key in d.
    iter(d)
        Возвращает итератор по ключам словаря. Это ярлык для iter(d.keys()).
    clear()
        Удалить все элементы из словаря.
    copy()
        Возвращает неглубокую копию словаря.
    classmethod fromkeys(iterable[, value])
        Создать новый словарь с ключами от iterable и значениями, установленными в value.
        fromkeys() — это метод класса, который возвращает новый словарь. value по умолчанию
None. Все значения относятся только к одному экземпляру, поэтому обычно не имеет смысла
использовать value в качестве изменяемого объекта, такого как пустой список. Чтобы получить
различные значения, используйте вместо этого словарное включение.
    get(key[, default])
        Возвращает значение key, если key находится в словаре, иначе default. Если значение
по умолчанию не указано, по умолчанию используется None, поэтому этот метод никогда
не вызывает KeyError.
    items()
        Возвращает новый вид элементов словаря (пары (key, value)). См. документацию
объектов представления.
    keys()
        Возвращает новое представление ключей словаря. См. документацию
объектов представления.
    pop(key[, default])
        Если key находится в словаре, удалить его и вернуть его значение, иначе вернуть
значение default. Если значение default не указано и key отсутствует в словаре,
возникает KeyError.
    popitem()
        Удалить и вернуть пару (key, value) из словаря. Пары возвращаются в порядке LIFO.
        popitem() полезен для деструктивного перебора словаря, что часто используется в
алгоритмах множества. Если словарь пуст, вызов popitem() вызывает KeyError.
        Изменено в версии 3.7: Порядок LIFO теперь гарантирован. В предыдущих версиях
popitem() возвращал произвольную пару ключ/значение.
    reversed(d)
        Возвращает обратный итератор по ключам словаря. Это ярлык для reversed(d.keys()).
        Добавлено в версии 3.8.
    setdefault(key[, default])
        Если key находится в словаре, вернуть его значение. Если нет, вставить key со
значением default и вернуть значение default. default — None.
    update([other])
        Обновить словарь парами ключ/значение из other, перезаписав существующие ключи.
Возвращает None.
        update() принимает либо другой объект словаря, либо итерацию пар ключ/значение
(в виде кортежей или других итераций длины два). Если указаны ключевые аргументы, словарь
обновляется этими парами ключ/значение: d.update(red=1, blue=2).
    values()
        Возвращает новое представление значений словаря. См. документация объектов
представления.
        Сравнение равенства между одним представлением dict.values() и другим всегда будет
возвращать False. Это также применимо при сравнении dict.values() с самим собой:
        >>> d = {'a': 1}
        >>> d.values() == d.values()
        False
     d | other
        Создайте новый словарь с объединенными ключами и значениями d и других, которые
должны быть словарями. Значения other имеют приоритет, когда d и other используют общие
ключи.
Новое в версии 3.9.
     d |= other
        Обновите словарь d ключами и значениями из других, которые могут быть либо
отображением, либо итерацией пар ключ/значение. Значения other имеют приоритет, когда d и
other используют общие ключи.
Новое в версии 3.9.

Словари сравниваются как равные тогда и только тогда, когда они имеют одинаковые пары
(key, value) (независимо от порядка). Сравнение порядков («<», «<=», «> =», «>») вызывает
TypeError.
Словари сохраняют порядок вставки. Обратите внимание, что обновление ключа не влияет на
порядок. Ключи, добавленные после удаления, вставляются в конце
    >>> d = {"one": 1, "two": 2, "three": 3, "four": 4}
    >>> d
    {'one': 1, 'two': 2, 'three': 3, 'four': 4}
    >>> list(d)
    ['one', 'two', 'three', 'four']
    >>> list(d.values())
    [1, 2, 3, 4]
    >>> d["one"] = 42
    >>> d
    {'one': 42, 'two': 2, 'three': 3, 'four': 4}
    >>> del d["two"]
    >>> d["two"] = None
    >>> d
    {'one': 42, 'three': 3, 'four': 4, 'two': None}

Изменено в версии 3.7: Порядок словаря гарантированно будет порядком вставки.
Такое поведение было деталью реализации CPython из версии 3.6. 
Словари и представления словарей обратимы.
    >>> d = {"one": 1, "two": 2, "three": 3, "four": 4}
    >>> d
    {'one': 1, 'two': 2, 'three': 3, 'four': 4}
    >>> list(reversed(d))
    ['four', 'three', 'two', 'one']
    >>> list(reversed(d.values()))
    [4, 3, 2, 1]
    >>> list(reversed(d.items()))
    [('four', 4), ('three', 3), ('two', 2), ('one', 1)]

Изменено в версии 3.8: Словари теперь обратимы.
См.также
types.MappingProxyType можно использовать для создания представления dict только для чтения.
