            Встроенные типы (Built-in Types)

В следующих разделах описаны стандартные типы, встроенные в интерпретатор.

Основными встроенными типами являются числа, последовательности, сопоставления, классы,
экземпляры и исключения.

Некоторые классы коллекций изменяемы. Методы, которые добавляют, вычитают или
переставляют элементы на месте и не возвращают конкретный элемент, никогда не возвращают
сам экземпляр коллекции, а возвращают None.

Некоторые операции поддерживаются несколькими типами объектов; в частности, практически
все объекты можно сравнивать на равенство, проверять на истинность и преобразовывать
в строку (с помощью функции repr() или немного отличающейся функции str()).
Последняя функция неявно используется, когда объект записывается функцией print().

            Truth Value Testing
            Проверка истинности

Любой объект может быть проверен на истинность, для использования в условиях if или
while или в качестве операнда логических операций, описанных ниже.
По умолчанию объект считается истинным, если его класс не определяет либо метод __bool__(),
возвращающий False, либо метод __len__(), возвращающий ноль при вызове с объектом.
Вот большинство встроенных объектов, которые считаются ложными:
     константы, определенные как ложные: None и False.
     ноль любого числового типа: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)
     пустые последовательности и коллекции: '', (), [], {}, set(), range(0)

Операции и встроенные функции, которые имеют логический результат, всегда возвращают 0 
или False для false и 1 или True для true, если не указано иное. (Важное исключение:
логические операции or и and всегда возвращают один из своих операндов.)

            Boolean Operations — and, or, not
            Логические операции — и, или, не

Это логические операции, упорядоченные по возрастанию приоритета:

Операция        Результат                               Примечание

x or y          if x is false, then y, else x           (1)
x and y         if x is false, then x, else y           (2)
not x           if x is false, then True, else False    (3)

Примечание
    1. Это оператор короткого замыкания, поэтому он оценивает второй аргумент только в
том случае, если первый ложен.
    2. Это оператор короткого замыкания, поэтому он оценивает второй аргумент только в
том случае, если первый истинен.
    3. not имеет более низкий приоритет, чем небулевы операторы, поэтому not a == b
интерпретируется как not (a == b), а a == not b является синтаксической ошибкой.

            Comparisons
            Cравнения

В Python есть восемь операций сравнения. Все они имеют одинаковый приоритет (который выше,
чем у булевых операций). Сравнения могут быть произвольными; например, x < y <= z 
эквивалентно x < y and y <= z, за исключением того, что y оценивается только один раз 
(но в обоих случаях z вообще не оценивается, когда x < y оказывается ложным).

В этой таблице приведены операции сравнения:

Operation       Meaning

<               строго меньше чем
<=              меньше или равно
>               строго больше, чем
>=              больше или равно
==              равный
!=              не равный
is              идентификатор объекта
is not          отрицательная идентичность объекта

Объекты разных типов, за исключением разных числовых типов, никогда не сравниваются равными.
Оператор == определен всегда, но для некоторых типов объектов (например, объектов класса)
эквивалентен is. Операторы <, <=, > и >= определяются только там, где они имеют смысл;
например, они вызывают исключение TypeError, когда один из аргументов является 
комплексным числом.
Неидентичные экземпляры класса обычно сравниваются как неравные, если только класс 
не определяет метод __eq__().
Экземпляры класса не могут быть упорядочены по отношению к другим экземплярам того же 
класса или другим типам объектов, если класс не определяет достаточное количество методов
__lt__(), __le__(), __gt__() и __ge__() (в общем случае, __lt__() и __eq__() достаточно,
если вам нужны общепринятые значения операторов сравнения).
Соответствие между символами операторов и именами методов следующее:
x<y    вызывает   x.__lt__(y)
x<=y   вызывает   x.__le__(y)
x==y   вызывает   x.__eq__(y)
x!= y  вызывает   x.__ne__(y)
x>y    вызывает   x.__gt__(y)
x>=y   вызывает   x.__ge__(y)
Поведение операторов is и is not нельзя настроить; также их можно применять к любым двум
объектам и никогда не вызывать исключения.
Еще две операции с одинаковым синтаксическим приоритетом, in и not in, поддерживаются 
типами, которые являются итерируемыми или реализуют метод __contains__().
