# 1. В то время как операции in и not in используются только для простой проверки наличия
# в общем случае, некоторые специализированные последовательности (например, str, bytes и
# bytearray) также используют их для тестирования подпоследовательностей

print("", "gg" in "eggs")

# 2. Значения n меньше 0 обрабатываются как 0 (что отдаёт пустую последовательность того же
# типа, что и s). Обратите внимание, что элементы в последовательности s не копируются;
# на них ссылаются несколько раз. Это часто не даёт покоя начинающим программистам на
# Python; рассмотрев возможность:

lists = [[]] * 3
print("\n", lists)
lists[0].append(3)
print("", lists)

# Случилось так, что [[]] является одноэлементным списком, содержащим пустой список,
# поэтому все три элемента [[]] * 3 являются ссылками на этот единственный пустой список.
# Изменение любого из элементов lists изменяет этот единственный список. Таким образом вы
# можете создать список из разных списков:

lists = [[] for i in range(3)]
lists[0].append(3)
lists[1].append(5)
lists[2].append(7)
print("\n", lists)

# Дополнительное объяснение доступно в разделе часто задаваемых вопросов
# "Как создать многомерный список?".

# 3. Если i или j отрицательны, индекс относится к концу последовательности s: заменяется
# len(s) + i или len(s) + j. Но обратите внимание, что -0 по-прежнему 0.

my_list = ['один', 'два', 'три', 'четыре', 'пять']
elem = my_list[-1]  # ['пять']
elem2 = my_list[len(my_list) -1]
print("\n", elem, "=", elem2)

# 4. Нарезка s от i до j определяется как последовательность элементов с индексом k,
# таким как i <= k < j. Если i или j больше len(s), используйте len(s). Если i пропущен
# или None, используйте 0. Если j не указан или None, используйте len(s). Если i больше
# или равно j, нарезка пуста.

my_list = ['один', 'два', 'три', 'четыре', 'пять', 'э', 'эа', '9', '20', '100', '5']
i, j = 1, 3
print("\n", my_list[i:j])
i, j = 2, 10
l = len(my_list)
print(my_list[i:l])
print(my_list[:-3])
print(my_list[:])
print("min(my_list) =", min(my_list))
print("max(my_list) =", max(my_list))

# 5. Нарезка s от i до j с шагом k определяется как последовательность элементов с индексом
# x = i + n*k, например 0 <= n < (j-i)/k. Другими словами, это индексы i, i+k, i+2*k, i+3*k
# и т. д., останавливающиеся при достижении j (но никогда не включая j). Когда k
# положительно, i и j уменьшаются до len(s), если они больше. Когда k отрицательно, i и j
# уменьшаются до len(s) - 1, если они больше. Если i или j пропущены или None, они
# становятся «конечными» значениями (конец которых зависит от знака k). Обратите внимание,
# k не может быть равным нулю. Если k равно None, он обрабатывается как 1.
k = 2
print("\nk = 2, my_list[1:9:k] =>", my_list[1:9:k])
print("k = 2, my_list[9:1:k] =>", my_list[9:1:k])
print("k = 2, my_list[-1:-9:k] =>", my_list[-1:-9:k])
print("k = 2, my_list[-9:-1:k] =>", my_list[-9:-1:k])
print()
k = -2
print("k = -2, my_list[1:9:k] =>", my_list[1:9:k])
print("k = -2, my_list[9:1:k] =>", my_list[9:1:k])
print("k = -2, my_list[-1:-9:k] =>", my_list[-1:-9:k])
print("k = -2, my_list[-9:-1:k] =>", my_list[-9:-1:k])

# 6. Объединение неизменяемых последовательностей всегда приводит к новому объекту. Это
# означает, что создание последовательности путём повторной конкатенации будет с
# квадратичными затратами времени выполнения от общей длины последовательности. Чтобы
# получить линейную стоимость времени выполнения, вы должны переключиться на одну из
# альтернатив, приведенных ниже:

#     a) при объединении объектов str вы можете создать список и использовать str.join()
# в конце или записать в экземпляр io.StringIO и получить его значение по завершении
#     b) при объединении объектов bytes можно аналогичным образом использовать bytes.join()
# или io.BytesIO или выполнить объединение на месте с объектом bytearray. Объекты bytearray
# являются изменяемыми и содержат эффективный механизм превышения доступности
#     c) при объединении объектов tuple, вместо этого расширьте list
#     d) для других типов изучите соответствующую документацию класса

# 7. Некоторые типы последовательностей (например, range) поддерживают только
# последовательности элементов, которые следуют определенным шаблонам, и, следовательно,
# не поддерживают конкатенацию или повторение последовательностей.

# 8. index вызывает ValueError, если x не находится в s. Не все реализации поддерживают
# передачу дополнительных аргументов i и j. Эти аргументы позволяют эффективно искать
# части последовательности. Передача дополнительных аргументов примерно эквивалентна
# использованию s[i:j].index(x), только без копирования каких-либо данных и с
# возвращаемым индексом, относящимся к началу последовательности, а не к началу нарезки.

s = (1, 2, 3, 4, 5, 2, 2,)
i, j = 1, 6
x = 3
print("\ns[i:j].index(x) =", s[i:j].index(x))
print("s[i:j] =", s[i:j])
print("s.count(2) =", s[i:j].count(2))

