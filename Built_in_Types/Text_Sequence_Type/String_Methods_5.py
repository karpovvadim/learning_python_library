print("-------str.splitlines(keepends=False)-------разделить строки -------------------")
# Возвращает список строк в строке, разрывая границы строк. Разрывы строк не включаются в
# результирующий список, если не указано значение keepends, равное true.
# Этот метод разбивается на следующие границы строк. В частности, границы представляют
# собой надмножество универсальных новых строк.
# Представление     Описание
# \n                Перевод строки
# \r                Возврат каретки
# \r\n              Возврат каретки + перевод строки
# \v или \x0b       Табулирование строк
# \f или \x0c       Подача формы
# \x1c              Разделитель файлов
# \x1d              Разделитель групп
# \x1e              Разделитель записей
# \x85              Следующая строка (контрольный код C1)
# \u2028            Разделитель строк
# \u2029            Разделитель абзацев
# Changed in version 3.2: \v and \f added to list of line boundaries.
# Изменено в версии 3.2: \v и \f добавлены в список границ строк.
grocery = 'Milk\nChicken\r\nBread\vButter'
print(grocery)
print(grocery.splitlines())
print(grocery.splitlines(True))
grocery = 'Milk Chicken Bread Butter'
print(grocery.splitlines())
print('ab c\n\nde fg\rkl\r\n'.splitlines())
print('ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True))
# В отличие от Split (), когда дается SEP строки разделителя, этот метод возвращает пустой
# список для пустой строки, а разрыв строки терминала не приводит к дополнительной линии:
print("".splitlines())
print("One line\n".splitlines())
print(''.split('\n'))  # Для сравнения, split('\n') дает:
print('Two lines\n'.split('\n'))
print("---------str.swapcase()---------подкачка--------------------------")
# Возвращает копию строки с символами верхнего регистра, преобразованными в нижний регистр,
# и наоборот. Для 8-битных строк (Юникод) результат метода зависит от локали.
# Обратите внимание, что не обязательно верно, что s.swapcase().swapcase() == s.
print("One LIne".swapcase())
print("-------str.title()------заглавие-------------------------------------")
# Возвращает версию строки в заглавном регистре, в которой слова начинаются с прописных
# букв, а остальные символы — строчными.
print('Hello world'.title())
# Алгоритм использует простое независимое от языка определение слова как группы
# последовательных букв. Это определение работает во многих контекстах, но оно означает,
# что апострофы в сокращениях и притяжательных падежах образуют границы слов, что может
# быть нежелательным результатом:
print("they're bill's friends from the UK".title())
# Функция string.capwords() не имеет этой проблемы, так как она разбивает слова только
# по пробелам.
# В качестве альтернативы обходной путь для апострофов может быть построен с
# использованием регулярных выражений:
import re


def titlecase(s):
    return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
                  lambda mo: mo.group(0).capitalize(),
                  s)


print(titlecase("they're bill's friends."))
print("------str.zfill(width)----------------------------------------")
# Вернуть копию строки, заполненную цифрами ASCII '0', чтобы создать строку длины и ширины.
# Префикс начального знака ('+'/'-') обрабатывается путем вставки заполнения после символа
# знака, а не перед ним. Исходная строка возвращается, если ширина меньше или равна len(s).
print("42".zfill(5))
print("-42".zfill(5))
number = "-290"
print(number.zfill(8))
number = "+290"
print(number.zfill(8))
text = "--random+text"
print(text.zfill(20))

