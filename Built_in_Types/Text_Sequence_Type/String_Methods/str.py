""" class str(object=b'', encoding='utf-8', errors='strict')"""
#     Возвращает строковый вариант object. Если object не указан, возвращает пустую строку.
# В противном случае поведение str() зависит от того, указана ли encoding или указаны errors,
# как показано ниже.

#     Если не указаны ни encoding, ни errors, str(object) возвращает
# type(object).__str__(object), которое является «неформальным» или хорошо печатаемым
# строковым представлением object. Для строкового object это сама строка. Если у объекта нет
# метода __str__(), то str() возвращает результат repr(object).

#     Если указано хотя бы одно из encoding или errors, object должен быть байтоподобным
# объектом (например, bytes или bytearray). В этом случае, если object является объектом
# bytes (или bytearray), то str(bytes, encoding, errors) эквивалентен
# bytes.decode(encoding, errors). В противном случае объект байтов, лежащий в основе
# буферного объекта, получается перед вызовом bytes.decode(). См. Типы двоичных
# последовательностей — bytes, bytearray, memoryview и Буферный протокол для получения
# информации о буферных объектах.

#     Передача объекта bytes в str() без аргументов encoding или errors подпадает под первый
# случай возврата неформального строкового представления (см. также параметр командной
# строки -b для Python). Например:

print(str(b'Zoot!'))

st_r = 'Zoot_ÆÇÈ'
print(st_r)
print(st_r.encode())
print(st_r.encode("ascii", "replace"))
print(st_r.encode("ascii", "ignore"))

#     Дополнительные сведения о классе str и его методах см. в разделе Тип текстовой
# последовательности str и Строковые методы ниже. Чтобы вывести форматированные строки,
# см. разделы Форматированные строковые литералы и Синтаксис строки формата. Кроме того,
# см. раздел Службы по обработке текста.
