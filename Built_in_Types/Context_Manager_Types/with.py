# The with statement
# Оператор with
#
# Оператор with используется для обёртывания выполнения блока методами, определенными менеджером
# контекста (см. раздел Оператор with контекстных менеджеров). Это позволяет инкапсулировать
# общие шаблоны использования try…except…finally для удобства повторного использования.

# with_stmt          ::=  "with" ( "(" with_stmt_contents ","? ")" | with_stmt_contents ) ":" suite
# with_stmt_contents ::=  with_item ("," with_item)*
# with_item          ::=  expression ["as" target]

# Выполнение оператора with с одним «элементом» происходит следующим образом
# 1. Выражение контекста (выражение, указанное в with_item) вычисляется для получения
#    менеджера контекста.
# 2. Загружается __enter__() менеджера контекста для дальнейшего использования.
# 3. Загружается __exit__() менеджера контекста для дальнейшего использования.
# 4. Вызывается метод __enter__() менеджера контекста.
# 5. Если целевой объект был включен в оператор with, ему присваивается возвращаемое
#    значение из __enter__().
#
#     Примечание
# Оператор with гарантирует, что если __enter__() метод вернется без ошибки, то всегда будет
# вызываться __exit__(). Таким образом, если вызывается ошибка во время назначения целевому
# списку, она будет обрабатываться так же, как и ошибка, вызываемая в наборе. См. шаг 6 ниже.

# 6. Набор выполнен.
# 7. Вызывается метод менеджера контекста __exit__(). Если исключение привело к выходу из
# набора, его тип, значение и трейсбэк передаются в качестве аргументов __exit__(). В
# противном случае предоставляются три аргумента None.

# Если выход из набора произошёл из-за исключения, а возвращаемое значение из
# метода __exit__() было ложным, исключение вызывается повторно. Если возвращаемое значение
# было истинно, исключение подавляется и выполнение продолжается с оператора, следующего за
# оператором with.

# Если выход из набора был выполнен по любой причине, кроме исключения, возвращаемое значение
# из __exit__() игнорируется, и выполнение продолжается в обычном месте для того вида выхода,
# который был принят.
#
# Следующий код:
import sys
from typing import TextIO

path = "text.txt"
expression = open(path, 'w')
data = "Hello World!"
with expression as file:
    file.write(data)

# семантически эквивалентен:
#
manager = open(path, 'w')
enter = type(manager).__enter__
exit = type(manager).__exit__
value = enter(manager)
hit_except = False

try:
    file = value
    file.write(data)
except:
    hit_except = True
    if not exit(manager, *sys.exc_info()):
        raise
finally:
    if not hit_except:
        exit(manager, None, None, None)

# С более чем одним элементом менеджеры контекста обрабатываются так, как будто несколько
# операторов with были вложены:

with open("text1.txt", "w") as f1, open("text2.txt", "w") as f2:
    f2.write("Ha-Ha-Ha")

# семантически эквивалентно:

with open("text1.txt", "w") as f1:
    with open("text2.txt", "w") as f2:
        f2.write("Ha-Ha-Ha")

# Изменено в версии 3.1: Поддержка нескольких контекстных выражений.
# Изменено в версии 3.10: Поддержка использования группирующих скобок для разделения
# оператора на несколько строк.
# См.также
# PEP 343 - Оператор «with»
#     Спецификация, предыстория и примеры для Python оператора with.
