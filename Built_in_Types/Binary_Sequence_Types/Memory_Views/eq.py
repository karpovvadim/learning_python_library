"""__eq__(exporter)"""
# Memoryview и экспортер PEP 3118 (Пересмотр буферного протокола) равны, если их формы
# эквивалентны и если все соответствующие значения равны, когда соответствующие коды
# формата операндов интерпретируются с использованием синтаксиса struct (Интерпретация
# байтов как упакованные двоичные данные).

# Для подмножества строк формата struct, поддерживаемых в настоящее время tolist()
# (Возвращает данные в буфере в виде списка элементов), v и w равны,
# если v.tolist() == w.tolist():

import array

a = array.array('I', [1, 2, 3, 4, 5])
b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])
c = array.array('b', [5, 3, 1])
x = memoryview(a)
y = memoryview(b)
print(x == a == y == b)  # True
print(x.tolist() == a.tolist() == y.tolist() == b.tolist())  # True
z = y[::-2]
print(z == c)  # True
print(z.tolist() == c.tolist())  # True

# Если какая-либо строка формата не поддерживается модулем struct, то объекты всегда
# будут сравниваться как неравные (даже если строки формата и содержимое буфера идентичны):

print('\n----Структура с обратным порядком байтов')
from ctypes import BigEndianStructure, c_long


class BEPoint(BigEndianStructure):  # Структура с обратным порядком байтов
    _fields_ = [("x", c_long), ("y", c_long)]


point = BEPoint(100, 200)
a = memoryview(point)
b = memoryview(point)
print(a == point)  # False
print(a == b)  # False

# Обратите внимание, что, как и в случае с числами с плавающей запятой, v is w
# не подразумевает v == w для объектов memoryview.

# Изменено в версии 3.3: Предыдущие версии сравнивали необработанную память без учёта
# формата элемента и структуры логического массива.
