            Memory Views
            Просмотры памяти

Объекты memoryview позволяют коду Python получать доступ к внутренним данным объекта,
который поддерживает буферный протокол, без копирования.

"""class memoryview(obj)"""

Создать memoryview, который ссылается на obj. obj должен поддерживать протокол буфера.
Встроенные объекты, поддерживающие протокол буфера, включают bytes и bytearray.

У memoryview есть понятие элемента, который представляет собой атомарную единицу
памяти, обрабатываемую исходным объектом obj. Для многих простых типов, таких как
bytes и bytearray, элемент является однобайтным, но другие типы, такие как
array.array, могут иметь элементы большего размера.

len(view) равен длине tolist. Если view.ndim = 0, длина равна 1. Если view.ndim = 1,
длина равна количеству элементов в представлении. Для более высоких измерений длина
равна длине представления в виде вложенного списка. Атрибут itemsize отдаст вам
количество байтов в одном элементе.

memoryview поддерживает нарезку и индексирование для предоставления своих данных.
Одномерная нарезка приведёт к субпредставлению.

Если format является одним из спецификаторов собственного формата из модуля struct,
индексирование с целым числом или кортежем целых чисел также поддерживается и возвращает
один элемент с правильным типом. Одномерные представления памяти могут быть
проиндексированы целым или одноцелочисленным кортежем. Многомерные представления памяти
могут быть проиндексированы кортежами ровно ndim целых чисел, где ndim — количество
измерений. Нульмерные просмотры памяти можно индексировать с помощью пустого кортежа.


Если базовый объект доступен для записи, memoryview поддерживает одномерное назначение
нарезки. Изменение размера не допускается.


Одномерные представления памяти хешируемых (только для чтения) типов с форматами «B», «b»
или «c» также могут быть хешированы. Хэш определяется как hash(m) == hash(m.tobytes()):

Изменено в версии 3.3: Одномерные представления памяти теперь можно нарезать. Одномерные
представления памяти с форматами «B», «b» или «c» теперь хешируются.
Изменено в версии 3.4: memoryview теперь автоматически регистрируется в
collections.abc.Sequence
Изменено в версии 3.5: memoryviews теперь можно индексировать с помощью кортежа целых чисел.

У memoryview есть несколько методов:

__eq__(exporter)     Memoryview и экспортер PEP 3118 (Пересмотр буферного протокола) равны

tobytes(order='C')   Возвращает данные в буфере в виде строки байтов

hex([sep[, bytes_per_sep]])  Возвращает строковый объект, содержащий две шестнадцатеричные
                            цифры для каждого байта в буфере

tolist()            Возвращает данные в буфере в виде списка элементов.

toreadonly()  Возвращает версию объекта memoryview только для чтения. Исходный объект
                memoryview не изменился.

release()  Освобождение нижележащего буфера. После вызова этого метода любая дальнейшая
                операция с представлением вызывает ValueError.

cast(format[, shape])  Преобразует memoryview в новый format или shape (форма)

Также доступно несколько атрибутов, доступных только для чтения:

obj

nbytes

readonly

 format
 
itemsize

ndim

shape

strides

suboffsets

c_contiguous

f_contiguous

contiguous