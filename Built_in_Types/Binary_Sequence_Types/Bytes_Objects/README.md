            Bytes Objects
            Объекты байтов

Объекты байтов — это неизменяемые последовательности отдельных байтов. Поскольку многие 
основные бинарные протоколы основаны на кодировке текста ASCII, байтовые объекты 
предлагают несколько методов, которые действительны только при работе с данными, 
совместимыми с ASCII, и тесно связаны со строковыми объектами множеством других способов.

"""class bytes([source[, encoding[, errors]]])"""

Во-первых, синтаксис для байтовых литералов в основном такой же, как и для строковых
литералов, за исключением добавления префикса b:
        Одинарные кавычки: b'по-прежнему допускает встроенные "двойные" кавычки'
        Двойные кавычки: b"по-прежнему допускает встроенные 'одиночные' кавычки".
        Тройное цитирование: b'''3 одинарные кавычки''', b"""3 двойные кавычки"""

В байтовых литералах разрешены только символы ASCII (независимо от заявленной кодировки 
исходного кода). Любые двоичные значения более 127 должны быть введены в байтовые литералы
с использованием соответствующей escape-последовательности.

Как и в случае строковых литералов, байтовые литералы могут также использовать префикс r 
для отключения обработки управляющих последовательностей. См. Строковые и байтовые 
литералы для получения дополнительной информации о различных формах байтовых литералов, 
включая поддерживаемые escape-последовательности.

В то время как байтовые литералы и представления основаны на тексте ASCII, байтовые объекты
фактически ведут себя как неизменяемые последовательности целых чисел, при этом каждое 
значение в последовательности ограничено таким образом, что 0 <= x < 256 (попытки нарушить
это ограничение вызовут ValueError). Это сделано намеренно, чтобы подчеркнуть, что это не
относится к произвольным двоичным данным. Хотя многие двоичные форматы включают элементы 
на основе ASCII и ими можно с пользой манипулировать с помощью некоторых 
текстово-ориентированных алгоритмов (слепое применение алгоритмов обработки текста к
двоичным форматам данных, которые не совместимы с ASCII, обычно приводит к повреждению
данных).

В дополнение к буквальным формам байтовые объекты могут быть созданы множеством других
способов:
        Заполненный нулями байтовый объект указанной длины: bytes(10)
        Из итерации целых чисел: bytes(range(20))
        Копирование существующих двоичных данных через буферный протокол: bytes(obj)
Также см. встроенную функцию bytes.

Поскольку две шестнадцатеричные цифры точно соответствуют одному байту, шестнадцатеричные
числа являются широко используемым форматом для описания двоичных данных. Соответственно,
у типа bytes есть дополнительный метод класса для чтения данных в этом формате:

"""classmethod fromhex(string)"""

Метод класса bytes возвращает объект байтов, декодируя заданный строковый объект. Строка
должна содержать две шестнадцатеричные цифры на байт, при этом пробелы ASCII игнорируются.

>>> bytes.fromhex('2Ef0 F1f2  ')
b'.\xf0\xf1\xf2'

Изменено в версии 3.7: bytes.fromhex() теперь пропускает все пробелы ASCII в строке,
а не только пробелы.

Функция обратного преобразования существует для преобразования байтового объекта в его
шестнадцатеричное представление.

   """hex([sep[, bytes_per_sep]])"""

Возвращает строковый объект, содержащий две шестнадцатеричные цифры для каждого байта 
в экземпляре.

>>> b'\xf0\xf1\xf2'.hex()
'f0f1f2'

Если вы хотите сделать шестнадцатеричную строку более удобной для чтения, вы можете указать
параметр sep-разделителя, состоящий из одного символа, для включения в вывод.
По умолчанию между каждым байтом. Второй необязательный параметр bytes_per_sep управляет
интервалом. Положительные значения вычисляют позицию разделителя справа, отрицательные
значения — слева.

>>> value = b'\xf0\xf1\xf2'
>>> value.hex('-')
'f0-f1-f2'
>>> value.hex('_', 2)
'f0_f1f2'
>>> b'UUDDLRLRAB'.hex(' ', -4)
'55554444 4c524c52 4142'

Добавлено в версии 3.5.
Изменено в версии 3.8: bytes.hex() теперь поддерживает необязательные параметры sep и
bytes_per_sep для вставки разделителей между байтами в шестнадцатеричном выводе.

Поскольку байтовые объекты представляют собой последовательности целых чисел (сродни 
кортежу), для байтового объекта b b[0] будет целым числом, а b[0:1] будет байтовым объектом
длины 1. (Это контрастирует с текстовыми строками, где и индексация, и нарезка будут
порождать строку длиной 1)

Для представления байтовых объектов используется буквальный формат (b'...'), поскольку он
часто более полезен, чем, например, bytes([46, 46, 46]). Вы всегда можете преобразовать
объект байтов в список целых чисел, используя list(b).

Примечание
Для пользователей Python 2.x: в серии Python 2.x были разрешены различные неявные
преобразования между 8-битными строками (наиболее близкое к встроенному двоичному типу
данных в 2.x) и строкам Юникод. Это был обходной путь обратной совместимости, чтобы учесть
тот факт, что Python изначально поддерживал только 8-битный текст, а текст Юникод был
добавлен позже. В Python 3.x эти неявные преобразования исчезли — преобразования между
8-битными двоичными данными и текстом Юникод должны быть явными, а байты и строковые
объекты всегда будут неравными.
