            printf-style Bytes Formatting
            Форматирование байтов в стиле printf

Примечание
Описанные здесь операции форматирования имеют ряд особенностей, которые приводят к ряду 
распространенных ошибок (например, неправильное отображение кортежей и словарей). Если 
печатаемое значение может быть кортежем или словарём, заключите его в кортеж.

У байтовых объектов (bytes / bytearray) есть одна уникальная встроенная операция:
оператор % (по модулю). Также известный как оператор форматирования байтов или
интерполяции. Учитывая format % values (где формат — объект байтов), спецификации
преобразования % в format заменяются нулём или несколькими элементами values. Эффект
аналогичен использованию sprintf() на языке C.

Если format требует одного аргумента, values могут быть одним объектом, не являющимся
кортежем. [5] в противном случае values должны быть кортежем с точно таким количеством
элементов, которое задано объектом байтов формата, или одним объектом отображения
(например, словарём).

Спецификатор преобразования содержит два или более символа и следующие компоненты,
которые должны встречаться в указанном порядке:
    1. Символ '%', который отмечает начало спецификатора.
    2. Ключ сопоставления (необязательно), состоящий из заключенной в скобки
последовательности символов (например, (somename)).
    3. Флаги преобразования (необязательно), которые влияют на результат некоторых типов
преобразования.
    4. Минимальная ширина поля (необязательно). Если указано как '*' (звёздочка),
фактическая ширина считывается из следующего элемента кортежа в значениях, а объект для
преобразования появляется после минимальной ширины поля и дополнительной точности.
    5. Точность (необязательно), задаётся как '.' (точка), за которой следует точность.
Если указано как '*' (звездочка), фактическая точность считывается из следующего
элемента кортежа в values, а значение для преобразования идёт после точности.
    6. Модификатор длины (необязательно).
    7. Тип конверсии.

Если правым аргументом является словарь (или другой тип сопоставления), тогда форматы в
объекте байтов должны включать в себя заключенный в скобки ключ сопоставления в этом
словаре, находящийся сразу после символа '%'. Ключ сопоставления выбирает значение для
форматирования из сопоставления. Например:

>>> print(b'%(language)s has %(number)03d quote types.' %
...       {b'language': b"Python", b"number": 2})
b'Python has 002 quote types.'

В этом случае спецификаторы * не могут встречаться в format (поскольку они требуют
последовательного списка параметров).

Символами флага преобразования являются:
Флаг 	Значение
'#' 	При преобразовании значение будет использоваться «альтернативная форма» 
        (где определено ниже).
'0' 	Преобразование будет заполнено нулями для числовых значений.
'-' 	Преобразованный значение корректируется слева (переопределяет преобразование '0',
        если заданы оба значения).
' ' 	(пробел) Пустота должна быть оставлена перед положительным числом (или пустой
        строкой), полученным путём преобразования со знаком.
'+' 	Знаковый символ ('+' или '-') будет предшествовать преобразованию (переопределяет
        флагу «space»).

Модификатор длины (h, l или L) может присутствовать, но игнорируется, поскольку он не
требуется для Python — например, %ld идентичен %d.

Типы конверсии:
Преобразование 	Значение 	Примечания
'd' 	Десятичное целое число со знаком. 	 
'i' 	Десятичное целое число со знаком. 	 
'o' 	Знаковое восьмеричное значение. 	(1)
'u' 	Устаревший тип — он идентичен 'd'. 	(8)
'x' 	Шестнадцатеричный со знаком (нижний регистр). 	(2)
'X' 	Шестнадцатеричный со знаком (верхний регистр). 	(2)
'e' 	Экспоненциальный формат с плавающей запятой (нижний регистр). 	(3)
'E' 	Экспоненциальный формат с плавающей запятой (верхний регистр). 	(3)
'f' 	Десятичный формат с плавающей запятой. 	(3)
'F' 	Десятичный формат с плавающей запятой. 	(3)
'g' 	Формат с плавающей запятой. Использует строчный экспоненциальный формат, если
        экспонента меньше 4 или не меньше точности, в противном случае - десятичный
        формат.                             	(4)
'G' 	Формат с плавающей запятой. Использует экспоненциальный формат верхнего регистра,
        если экспонента меньше 4 или не меньше точности, в противном случае — десятичный
        формат. 	                            (4)
'c' 	Одиночный байт (принимает целочисленные или однобайтовые объекты). 	 
'b' 	Байты (любой объект, следующий буферному протоколу или имеющий __bytes__()).  (5)
's' 	's' - алиас для 'b' и должен использоваться только в для Python2/3 основанном
        коде. 	                                (6)
'a' 	Байты (преобразует любой Python объект с помощью repr(obj).encode('ascii',
        'backslashreplace)). 	                (5)
'r' 	'r' - алиас для 'a' и должен использоваться только для Python2/3
        основанном коде. 	                    (7)
'%' 	Ни один аргумент не преобразуется, что приводит к '%' символу в результате.

Примечания:
    1. В альтернативной форме перед первой цифрой вставляется начальный восьмеричный
спецификатор ('0o').
    2. Альтернативная форма приводит к вставке перед первой цифрой ведущего '0x' или '0X'
(в зависимости от того, использовался ли формат 'x' или 'X').
    3. Альтернативная форма приводит к тому, что результат всегда содержит десятичную
точку, даже если за ней нет цифр.
    4. Точность определяет количество цифр после десятичной точки и по умолчанию
составляет 6.
    Альтернативная форма приводит к тому, что результат всегда содержит десятичную точку,
а конечные нули не удаляются, как в противном случае.
    Точность определяет количество значащих цифр до и после десятичной точки и по
умолчанию составляет 6.
    5. Если точность равна N, вывод усекается до символов N.
    6. b'%s' устарел, но не будет удалён в серии 3.x.
    7. b'%r' устарел, но не будет удалён в серии 3.x.
    8. См. PEP 237.

Примечание
Версия этого метода bytearray не работает на месте — она всегда создаёт новый объект,
даже если не было никаких изменений.
См.также
PEP 461 — добавление %-форматирования к байтам и байтовому массиву
Добавлено в версии 3.5.
